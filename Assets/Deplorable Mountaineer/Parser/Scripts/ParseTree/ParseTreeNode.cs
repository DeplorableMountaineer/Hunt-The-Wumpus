#region

using System;
using System.Collections.Generic;
using Deplorable_Mountaineer.Parser.Tokens;

#endregion

namespace Deplorable_Mountaineer.Parser.ParseTree {
    /// <summary>
    ///     A node of a parse tree, generated by <see cref="WumpusParser" />.
    /// </summary>
    public class ParseTreeNode {
        /// <summary>
        ///     The ordered children of the node (if it is a nonterminal)
        /// </summary>
        private readonly List<ParseTreeNode> _children;

        /// <summary>
        ///     Create a node for a nonterminal symbol
        /// </summary>
        /// <param name="nonterminal">The name of the nonterminal</param>
        public ParseTreeNode(string nonterminal){
            IsNonterminal = true;
            _children = new List<ParseTreeNode>();
            Nonterminal = nonterminal;
            TokenName = nonterminal;
            TokenType = TokenType.NotAToken;
            TokenText = null;
        }

        /// <summary>
        ///     Create a token node
        /// </summary>
        /// <param name="name">
        ///     The name of the token (<see cref="TokenUtils.GuessTokenType" />
        ///     for how it can be formatted)
        /// </param>
        /// <param name="text">The text that the token matched</param>
        public ParseTreeNode(string name, string text){
            IsNonterminal = false;
            _children = null;
            Nonterminal = null;
            TokenType = TokenUtils.GuessTokenType(name, out string normalizedName);
            TokenName = normalizedName;
            TokenText = text;
        }

        /// <summary>
        ///     The ordered children of the node (if it is a nonterminal)
        /// </summary>
        public IReadOnlyList<ParseTreeNode> Children => _children;

        /// <summary>
        ///     True if this node is a nonterminal symbol
        /// </summary>
        public bool IsNonterminal { get; }

        /// <summary>
        ///     The name of the nonterminal symbol, if it is a nonterminal node
        /// </summary>
        public string Nonterminal { get; }

        /// <summary>
        ///     The name of the token, if it is a terminal symbol (token) node
        /// </summary>
        public string TokenName { get; }

        /// <summary>
        ///     The type of token if it is a terminal symbol node
        /// </summary>
        public TokenType TokenType { get; }

        /// <summary>
        ///     The matched text of the token if it is a terminal symbol node
        /// </summary>
        public string TokenText { get; }

        /// <summary>
        ///     Clear the children of the node
        /// </summary>
        public void Clear(){
            _children.Clear();
        }

        /// <summary>
        ///     Add a child node
        /// </summary>
        /// <param name="node">The node to add</param>
        public void AddChild(ParseTreeNode node){
            _children.Add(node);
        }

        /// <summary>
        ///     Create a nonterminal node and add it as a child
        /// </summary>
        /// <param name="nonterminal">The name of the nonterminal symbol</param>
        public void AddChild(string nonterminal){
            AddChild(new ParseTreeNode(nonterminal));
        }

        /// <summary>
        ///     Create a token node and add it as a child
        /// </summary>
        /// <param name="name">
        ///     The name of the token (<see cref="TokenUtils.GuessTokenType" />
        ///     for how it can be formatted)
        /// </param>
        /// <param name="text"></param>
        public void AddChild(string name, string text){
            AddChild(new ParseTreeNode(name, text));
        }

        /// <summary>
        ///     Convert the parse tree back into text
        /// </summary>
        /// <param name="newlineAfter">
        ///     Format result by putting a newline after occurrences of this
        ///     substring
        /// </param>
        /// <param name="moreNewlineAfter">
        ///     Format result by putting a newline after occurrences of these
        ///     substrings
        /// </param>
        /// <returns>The decompiled text</returns>
        public string Decompile(string newlineAfter = ";", params string[] moreNewlineAfter){
            if(!IsNonterminal) return TokenText;
            string result = "";
            foreach(ParseTreeNode child in _children){
                if(result != "") result += " ";
                result += child.Decompile();
            }

            result = result.Replace(newlineAfter, newlineAfter + "\n");
            foreach(string m in moreNewlineAfter)
                result = result.Replace(m, m + "\n");
            return result;
        }

        /// <summary>
        ///     Return a string showing the node and all its descendents
        /// </summary>
        /// <returns>The node description</returns>
        public string RecursiveString(){
            string result = ToString() + "\n";
            if(!IsNonterminal) return result;
            foreach(ParseTreeNode child in _children){
                if(!child.IsNonterminal) continue;
                result += child.RecursiveString();
            }

            return result;
        }

        /// <summary>
        ///     Return a string describing the node, but only its immediate children
        /// </summary>
        /// <returns>The node description</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        ///     Should never happen; would
        ///     indicate an error in the code
        /// </exception>
        public override string ToString(){
            if(!IsNonterminal)
                return TokenType switch {
                    TokenType.StringLiteral => TokenName,
                    TokenType.NamedToken => $"{TokenName}({TokenText})",
                    TokenType.ExplicitRegex => $"{TokenName}({TokenText})",
                    _ => throw new ArgumentOutOfRangeException()
                };

            string result = $"{Nonterminal} =>";
            foreach(ParseTreeNode child in _children)
                if(child.IsNonterminal)
                    result += $" {child.Nonterminal}";
                else result += $" {child}";

            result += ";";
            return result;
        }
    }
}
